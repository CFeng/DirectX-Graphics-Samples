//
// Copyright (c) Microsoft. All rights reserved.
// This code is licensed under the MIT License (MIT).
// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
// PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
// Developed by Minigraph
//
// Author:  James Stanard 
//

#include "SSSRRS.hlsli"

RWTexture2D<float4> OutRayCast : register(u0);
RWTexture2D<float> OutRayCastMask : register(u1);

cbuffer CB1 : register(b1)
{
    float3 _WorldSpaceCameraPos;

    float4x4 _InverseProjectionMatrix;
    float4x4 _InverseViewProjectionMatrix;
    float4x4 _WorldToCameraMatrix;

    float4 _ProjectionParams;
    float4 _ZBufferParams;

    float4 _JitterSizeAndOffset; // x = jitter width / screen width, y = jitter height / screen height, z = random offset, w = random offset

    float4x4 _ProjectionMatrix;

    uint2 _RayCastSize;	// width, height
    uint2 _NoiseSize;	// width, height
}

#include "SSRLib.hlsli"
#include "BRDFLib.hlsli"
#include "RayTraceLib.hlsli"

Texture2D<float3> _Noise : register(t5);
Texture2D<float> LNDepthBuffer : register(t6);        // Linear/normalized depth buffer

[RootSignature(SSSR_RootSig)]
[numthreads(8, 8, 1)]
void main(uint3 DTid : SV_DispatchThreadID, uint GI : SV_GroupIndex, uint3 GTid : SV_GroupThreadID, uint3 Gid : SV_GroupID)
{
    uint2 st = DTid.xy;
    float2 uv = (st + 0.5) / _RayCastSize;  // STtoUV, TODO: use rcp to save the "/"?

    float3 worldNormal = GetNormal(uv);
    //float3 viewNormal = GetViewNormal(worldNormal);
    float4 specular = GetSpecular(uv);
    float roughness = GetRoughness(specular.a);

    float depth = GetDepth(uv);
    float3 screenPos = GetScreenPos(uv, depth);

    float3 worldPos = GetWorlPos(screenPos);
    float3 viewDir = GetViewDir(worldPos);

    float3 viewPos = /*mul(_WorldToCameraMatrix, float4(worldPos, 1.0))*/ GetViewPos(screenPos);

    float2 jitter = _Noise.SampleLevel(AnisoWrapSampler, (uv + _JitterSizeAndOffset.zw) * _RayCastSize.xy / _NoiseSize.xy, 0); // Blue noise generated by https://github.com/bartwronski/BlueNoiseGenerator/;
    //float2 jitter = _Noise[(st + uint2(_JitterSizeAndOffset.zw * _RayCastSize)) % _NoiseSize]; // Blue noise generated by https://github.com/bartwronski/BlueNoiseGenerator/;

    float2 Xi = jitter;

    Xi.y = lerp(Xi.y, 0.0, 0.7);    // _BRDFBias = 0.7

    float4 localH = ImportanceSampleGGX(Xi, roughness);
    float4 H = TangentToWorld(worldNormal, localH);
    float3 dir2 = reflect(viewDir, H.xyz);
    float3 dir = normalize(mul((float3x3)_WorldToCameraMatrix, dir2));

    jitter += 0.5f;

    const int _NumSteps = 70;

    float stepSize = (1.0 / (float)_NumSteps);
    stepSize = stepSize * (jitter.x + jitter.y) + stepSize;

    float2 rayTraceHit = 0.0;
    float rayTraceZ = 0.0;
    float rayPDF = 0.0;
    float rayMask = 0.0;
    float4 rayTrace = RayMarch(_ProjectionMatrix, dir, _NumSteps, viewPos, screenPos, uv, stepSize, 1.0);

    rayTraceHit = rayTrace.xy;
    rayTraceZ = rayTrace.z;
    rayPDF = H.w;
    rayMask = rayTrace.w;

    OutRayCast[st] = float4(rayTrace);    // float4(rayTraceHit, rayTraceZ, rayPDF);
    OutRayCastMask[st] = rayMask;
}
