//
// Copyright (c) Microsoft. All rights reserved.
// This code is licensed under the MIT License (MIT).
// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
// PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
// Developed by Minigraph
//
// Author:  James Stanard 
//

#include "SSSRRS.hlsli"

Texture2D<float3> _Noise : register(t5);
Texture2D<float4> _MainTex : register(t6);
Texture2D<float4> _RayCast : register(t7);
Texture2D<float> _RayCastMask : register(t8);

RWTexture2D<float4> OutColor : register(u0);

cbuffer CB1 : register(b1)
{
	float3 _WorldSpaceCameraPos;

	float4x4 _InverseProjectionMatrix;
	float4x4 _InverseViewProjectionMatrix;
	float4x4 _WorldToCameraMatrix;

	float4 _SinTime; // sin(t/8), sin(t/4), sin(t/2), sin(t)

	float4 _JitterSizeAndOffset; // x = jitter width / screen width, y = jitter height / screen height, z = random offset, w = random offset

    uint2 _ScreenSize;	// width, height
	uint2 _ResolveSize;
	uint2 _NoiseSize;	// width, height
}

#include "SSRLib.hlsli"
#include "BRDFLib.hlsli"

float2 RandN2(float2 pos, float2 random)
{
	return frac(sin(dot(pos.xy + random, float2(12.9898, 78.233))) * float2(43758.5453, 28001.8384));
}

static const float2 offset[4] =
{
	float2(0, 0),
	float2(2, -2),
	float2(-2, -2),
	float2(0, 2)
};

//float RayAttenBorder(float2 pos, float value)
//{
//	float borderDist = min(1.0 - max(pos.x, pos.y), min(pos.x, pos.y));
//	return saturate(borderDist > value ? 1.0 : borderDist / value);
//}

[RootSignature(SSSR_RootSig)]
[numthreads(8, 8, 1)]
void main(uint3 DTid : SV_DispatchThreadID, uint GI : SV_GroupIndex, uint3 GTid : SV_GroupThreadID, uint3 Gid : SV_GroupID)
{
    uint2 pos = DTid.xy;
    float2 uv = (pos + 0.5) / _ScreenSize;  // STtoUV, TODO: use rcp to save the "/"?

	float3 worldNormal = GetNormal(uv);
	float3 viewNormal = GetViewNormal(worldNormal);
	float4 specular = GetSpecular(uv);
	float roughness = GetRoughness(specular.a);

	float depth = GetDepth(uv);
	float3 screenPos = GetScreenPos(uv, depth);
	float3 worldPos = GetWorlPos(screenPos);
	float3 viewPos = GetViewPos(screenPos);
	float3 viewDir = GetViewDir(worldPos);

	float2 random = RandN2(pos, _SinTime.xx /** _UseTemporal*/);

	// Blue noise generated by https://github.com/bartwronski/BlueNoiseGenerator/
	float2 blueNoise = _Noise.SampleLevel(PointSampler, ((uv + _JitterSizeAndOffset.zw) * _ScreenSize.xy / _NoiseSize.xy) * 2.0 - 1.0, 0); // works better with [-1, 1] range
	float2x2 offsetRotationMatrix = float2x2(blueNoise.x, blueNoise.y, -blueNoise.y, blueNoise.x);

	int NumResolve = 1;
	//if (_RayReuse == 1)
		NumResolve = 4;


    float NdotV = saturate(dot(worldNormal, -viewDir));
    float coneTangent = lerp(0.0, roughness * (1.0 - 0.7), NdotV * sqrt(roughness));	// _BRDFBias = 0.7

    float maxMipLevel = (float)5 - 1.0;	// _MaxMipMap = 5

	float4 result = 0.0;
	float weightSum = 0.0;
	for (int i = 0; i < NumResolve; i++)
	{
		float2 offsetUV = offset[i] * (1.0 / _ResolveSize.xy);
		offsetUV = mul(offsetRotationMatrix, offsetUV);

		// "uv" is the location of the current (or "local") pixel. We want to resolve the local pixel using
		// intersections spawned from neighboring pixels. The neighboring pixel is this one:
		float2 neighborUv = uv + offsetUV;

		// Now we fetch the intersection point and the PDF that the neighbor's ray hit.
		float4 hitPacked = _RayCast.SampleLevel(PointSampler, neighborUv, 0);
		float2 hitUv = hitPacked.xy;
		float hitZ = hitPacked.z;
		float hitPDF = hitPacked.w;
		float hitMask = _RayCastMask.SampleLevel(PointSampler, neighborUv, 0).r;

		float3 hitViewPos = GetViewPos(GetScreenPos(hitUv, hitZ));

		// We assume that the hit point of the neighbor's ray is also visible for our ray, and we blindly pretend
		// that the current pixel shot that ray. To do that, we treat the hit point as a tiny light source. To calculate
		// a lighting contribution from it, we evaluate the BRDF. Finally, we need to account for the probability of getting
		// this specific position of the "light source", and that is approximately 1/PDF, where PDF comes from the neighbor.
		// Finally, the weight is BRDF/PDF. BRDF uses the local pixel's normal and roughness, but PDF comes from the neighbor.
		float weight = 1.0;
		//if (_UseNormalization == 1)
			weight = BRDF_Unity_Weight(normalize(-viewPos) /*V*/, normalize(hitViewPos - viewPos) /*L*/, viewNormal /*N*/, roughness) / max(1e-5, hitPDF);

		float intersectionCircleRadius = coneTangent * length(hitUv - uv);
		float mip = clamp(log2(intersectionCircleRadius * max(_ResolveSize.x, _ResolveSize.y)), 0.0, maxMipLevel);

		float4 sampleColor = float4(0.0, 0.0, 0.0, 1.0);
		sampleColor.rgb = _MainTex.SampleLevel(LinearSampler, hitUv, mip).rgb;
		sampleColor.a = /*RayAttenBorder(hitUv, _EdgeFactor) **/ hitMask;

		//if (_Fireflies == 1)
			sampleColor.rgb /= 1 + Luminance(sampleColor.rgb);

		result += sampleColor * weight;
		weightSum += weight;
	}
	result /= weightSum;

	//if (_Fireflies == 1)
		result.rgb /= 1 - Luminance(result.rgb);

	OutColor[pos] = max(1e-5, result);
}
